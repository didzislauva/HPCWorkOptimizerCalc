<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HPC Work Split Optimizer</title>
  <style>
    :root {
      --primary: #3498db;
      --primary-dark: #2980b9;
      --secondary: #2ecc71;
      --background: #f8f9fa;
      --text: #333;
      --border: #ddd;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      background-color: var(--background);
      color: var(--text);
      line-height: 1.6;
    }
    
    .container {
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 25px;
      margin-bottom: 20px;
    }
    
    h1, h2, h3 {
      color: var(--primary-dark);
    }
    
    .info-section {
      margin-bottom: 30px;
      border-left: 4px solid var(--primary);
      padding-left: 15px;
    }
    
    .formula {
      background-color: #f1f8ff;
      padding: 10px;
      border-radius: 5px;
      font-family: monospace;
      margin: 10px 0;
    }
    
    .input-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    
    input[type="number"] {
      width: 100px;
      padding: 8px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
    }
    
    button {
      background-color: var(--primary);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s;
    }
    
    button:hover {
      background-color: var(--primary-dark);
    }
    
    textarea {
      width: 100%;
      height: 300px;
      padding: 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      resize: vertical;
    }
    
    .debug-info {
      margin-top: 20px;
      background-color: #f9f2f4;
      color: #c7254e;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      display: none;
    }
    
    .tab {
      overflow: hidden;
      border: 1px solid var(--border);
      background-color: #f1f1f1;
      border-radius: 4px 4px 0 0;
    }
    
    .tab button {
      background-color: inherit;
      float: left;
      border: none;
      outline: none;
      cursor: pointer;
      padding: 10px 16px;
      transition: 0.3s;
      color: var(--text);
    }
    
    .tab button:hover {
      background-color: #ddd;
    }
    
    .tab button.active {
      background-color: var(--primary);
      color: white;
    }
    
    .tabcontent {
      display: none;
      padding: 20px;
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 4px 4px;
      animation: fadeEffect 1s;
    }
    
    @keyframes fadeEffect {
      from {opacity: 0;}
      to {opacity: 1;}
    }
    
    .visualization {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .machine-bar {
      background-color: #e0e0e0;
      height: 30px;
      border-radius: 4px;
      position: relative;
    }
    
    .machine-progress {
      background-color: var(--secondary);
      height: 100%;
      border-radius: 4px;
      transition: width 0.5s;
      display: flex;
      align-items: center;
      padding-left: 10px;
      color: white;
      font-weight: bold;
    }
    
    .tooltip {
      position: relative;
      display: inline-block;
      cursor: help;
    }
    
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 250px;
      background-color: #555;
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    
    summary {
      cursor: pointer;
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .example-section {
      background-color: #f9f9f9;
      padding: 15px;
      border-radius: 5px;
      margin-top: 15px;
    }
    
    .debug-toggle {
      margin-top: 10px;
      font-size: 12px;
      color: #777;
      cursor: pointer;
      text-align: right;
    }
    
    .advanced-settings {
      margin-top: 20px;
      padding: 15px;
      background-color: #f5f5f5;
      border-radius: 5px;
      border: 1px solid #ddd;
    }
    
    .advanced-settings h3 {
      margin-top: 0;
    }
    
    input:disabled {
      background-color: #f1f1f1;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>HPC Work Split Optimizer</h1>
    
    <div class="info-section">
      <h2>What is this tool?</h2>
      <p>
        This application helps you optimize task distribution across multiple heterogeneous computing resources
        (like servers, workstations, or compute nodes in a High-Performance Computing cluster).
        It calculates the optimal chunk distribution to minimize idle time and maximize overall throughput
        when machines have different performance characteristics.
      </p>
    </div>
    
    <div class="tab">
      <button class="tablinks active" onclick="openTab(event, 'calculator')">Calculator</button>
      <button class="tablinks" onclick="openTab(event, 'about')">How It Works</button>
      <button class="tablinks" onclick="openTab(event, 'examples')">Examples & Use Cases</button>
    </div>
    
    <div id="calculator" class="tabcontent" style="display: block;">
      <h2>Work Distribution Calculator</h2>
      
      <p>
        Enter the relative performance of each machine compared to the first machine (machine 1). 
        For example, if machine 2 is 50% faster than machine 1, enter "50". 
        If it's 20% slower, enter "-20".
        <span class="tooltip">ℹ️
          <span class="tooltiptext">Leave fields empty for machines you don't want to include in the calculation.</span>
        </span>
      </p>
      
      <div class="input-grid" id="machineInputs"></div>
      
      <label>
        Total computation time for machine 1 (in minutes): 
        <input type="number" id="totalTime" value="600" min="1">
        <span class="tooltip">ℹ️
          <span class="tooltiptext">This is how long the entire workload would take if run on machine 1 alone.</span>
        </span>
      </label>
      
      <div class="advanced-settings">
        <h3>Advanced Settings</h3>
        <label>
          Maximum chunks to consider: 
          <input type="number" id="maxChunks" value="100" min="1" max="100000">
          <span class="tooltip">ℹ️
            <span class="tooltiptext">Higher values may find more optimal solutions but take longer to calculate.</span>
          </span>
        </label>
        
        <label>
          Maximum acceptable wait time (minutes): 
          <input type="number" id="maxWaitTime" value="1" min="0.01" step="0.01">
          <span class="tooltip">ℹ️
            <span class="tooltiptext">The algorithm will stop searching once it finds a solution with a wait time below this threshold.</span>
          </span>
        </label>
        
        <label style="display:none">
          <input type="checkbox" id="enforceNonZero" checked>
          Ensure all machines get work
          <span class="tooltip">ℹ️
            <span class="tooltiptext">When checked, the algorithm will ensure every machine gets at least one chunk, even if it's less efficient.</span>
          </span>
        </label>
        
        <label>
          <input type="checkbox" id="debugMode">
          Enable debug mode
          <span class="tooltip">ℹ️
            <span class="tooltiptext">Shows additional diagnostic information about the calculations.</span>
          </span>
        </label>
      </div>
      
      <button onclick="calculateOptimalSplit()">Calculate Optimal Split</button>
      
      <h3>Results</h3>
      <textarea id="result" readonly></textarea>
      <div id="debugInfo" class="debug-info"></div>
      
      <div class="visualization" id="visualization"></div>
    </div>
    
    <div id="about" class="tabcontent">
      <h2>How It Works</h2>
      
      <details open>
        <summary>The Problem</summary>
        <p>
          When distributing computational workloads across machines with different performance capabilities,
          a naïve approach (like equal distribution) often leads to inefficiency. Faster machines finish early
          and sit idle while slower machines are still working.
        </p>
        <p>
          The goal is to find a distribution where all machines finish at approximately the same time,
          minimizing the total wait time.
        </p>
      </details>
      
      <details>
        <summary>The Algorithm</summary>
        <p>
          This tool uses an exhaustive search algorithm to find an optimal distribution of work chunks:
        </p>
        <ol>
          <li>First, it normalizes the performance of all machines relative to the baseline (machine 1).</li>
          <li>It divides the total workload into a number of discrete chunks.</li>
          <li>It systematically tries different distributions of these chunks across machines.</li>
          <li>It calculates the completion time for each machine based on its assigned chunks and relative speed.</li>
          <li>It identifies the distribution that minimizes the difference between the fastest and slowest completion times.</li>
        </ol>
        <p class="formula">
          Time for machine i = (chunks assigned to machine i / total chunks) × (base time / relative speed of machine i)
        </p>
      </details>
      
      <details>
        <summary>Performance Considerations</summary>
        <p>
          The algorithm's search space grows exponentially with the number of machines and chunks.
          For practical purposes:
        </p>
        <ul>
          <li>The tool limits the search to a reasonable number of chunks (default 100).</li>
          <li>It stops searching once it finds a distribution with a wait time under a specified threshold (default 1 minute).</li>
          <li>For complex scenarios with many machines of varying speeds, you may need to increase the chunk limit.</li>
        </ul>
      </details>
      
      <details>
        <summary>The Zero-Chunk Problem</summary>
        <p>
          In some cases, the mathematically optimal solution might exclude certain machines (assign them zero chunks).
          This can happen when:
        </p>
        <ul>
          <li>A machine is significantly slower than others.</li>
          <li>The relative speeds don't allow for a perfect distribution given the number of chunks.</li>
        </ul>
        <p>
          You can force the algorithm to assign at least one chunk to each machine by enabling the "Ensure all machines get work" option,
          though this might result in a slightly less efficient overall solution.
        </p>
      </details>
    </div>
    
    <div id="examples" class="tabcontent">
      <h2>Examples & Use Cases</h2>
      
      <h3>When to Use This Tool</h3>
      <p>
        This optimizer is particularly useful for:
      </p>
      <ul>
        <li>Distributed computing tasks that can be divided into discrete chunks</li>
        <li>Heterogeneous computing environments with machines of varying performance</li>
        <li>Batch processing jobs where minimizing total completion time is critical</li>
        <li>Scientific computing workloads spanning multiple compute nodes</li>
        <li>Rendering farms with a mix of hardware generations</li>
      </ul>
      
      <div class="example-section">
        <h3>Example 1: Mixed Performance Cluster</h3>
        <p>
          <strong>Data Processing Pipeline:</strong> You have 3 machines with different capabilities:
        </p>
        <ul>
          <li>Machine 1: Your baseline server (100%)</li>
          <li>Machine 2: A newer server that's 75% faster (175%)</li>
          <li>Machine 3: An older machine that's 30% slower (70%)</li>
        </ul>
        <button onclick="loadExample1()">Load This Example</button>
      </div>
      
      <div class="example-section">
        <h3>Example 2: Equal Machines with One Fast</h3>
        <p>
          Three machines where two are identical and one is faster:
        </p>
        <ul>
          <li>Machine 1: Baseline (100%)</li>
          <li>Machine 2: Same as baseline (100%)</li>
          <li>Machine 3: 50% faster (150%)</li>
        </ul>
        <button onclick="loadExample2()">Load This Example</button>
      </div>
      
      <div class="example-section">
        <h3>Example 3: Equal Machines with One Slow</h3>
        <p>
          Three machines where two are identical and one is slower:
        </p>
        <ul>
          <li>Machine 1: Baseline (100%)</li>
          <li>Machine 2: Same as baseline (100%)</li>
          <li>Machine 3: 50% slower (50%)</li>
        </ul>
        <button onclick="loadExample3()">Load This Example</button>
      </div>
    </div>
  </div>
  
  <script>
    // Initialize machine inputs
    const machineCount = 10;
    const inputContainer = document.getElementById("machineInputs");
    
    for (let i = 0; i < machineCount; i++) {
      const label = document.createElement("label");
      let placeholderText = i === 0 ? "Baseline (0%)" : "% relative to machine 1";
      let defaultValue = i === 0 ? "0" : "";
      label.innerHTML = `Machine ${i + 1}: <input type="number" id="machine${i}" value="${defaultValue}" placeholder="${placeholderText}">`;
      inputContainer.appendChild(label);
    }
    
    // Debug mode toggle
    document.getElementById("debugMode").addEventListener("change", function() {
      document.getElementById("debugInfo").style.display = this.checked ? "block" : "none";
    });
    
    // Tab functionality
    function openTab(evt, tabName) {
      const tabcontent = document.getElementsByClassName("tabcontent");
      for (let i = 0; i < tabcontent.length; i++) {
        tabcontent[i].style.display = "none";
      }
      
      const tablinks = document.getElementsByClassName("tablinks");
      for (let i = 0; i < tablinks.length; i++) {
        tablinks[i].className = tablinks[i].className.replace(" active", "");
      }
      
      document.getElementById(tabName).style.display = "block";
      evt.currentTarget.className += " active";
    }
    
    // Load example 1
    function loadExample1() {
      document.getElementById("machine0").value = "0";
      document.getElementById("machine1").value = "75";
      document.getElementById("machine2").value = "-30";
      for (let i = 3; i < machineCount; i++) {
        document.getElementById(`machine${i}`).value = "";
      }
      document.getElementById("totalTime").value = "600";
      
      // Switch to calculator tab
      const calculatorTab = document.querySelector('.tablinks');
      calculatorTab.click();
      
      // Calculate results
      calculateOptimalSplit();
    }
    
    // Load example 2
    function loadExample2() {
      document.getElementById("machine0").value = "0";
      document.getElementById("machine1").value = "0";
      document.getElementById("machine2").value = "50";
      for (let i = 3; i < machineCount; i++) {
        document.getElementById(`machine${i}`).value = "";
      }
      document.getElementById("totalTime").value = "600";
      
      // Switch to calculator tab
      const calculatorTab = document.querySelector('.tablinks');
      calculatorTab.click();
      
      // Calculate results
      calculateOptimalSplit();
    }
    
    // Load example 3
    function loadExample3() {
      document.getElementById("machine0").value = "0";
      document.getElementById("machine1").value = "0";
      document.getElementById("machine2").value = "-50";
      for (let i = 3; i < machineCount; i++) {
        document.getElementById(`machine${i}`).value = "";
      }
      document.getElementById("totalTime").value = "600";
      
      // Switch to calculator tab
      const calculatorTab = document.querySelector('.tablinks');
      calculatorTab.click();
      
      // Calculate results
      calculateOptimalSplit();
    }
    
// Replace the calculateOptimalSplit function with this fixed version
// Modify the calculateOptimalSplit function to handle no solution found case
function calculateOptimalSplit() {
  const baseTime = parseFloat(document.getElementById("totalTime").value);
  const maxChunks = parseInt(document.getElementById("maxChunks").value);
  const initialMaxWaitTime = parseFloat(document.getElementById("maxWaitTime").value);
  const enforceNonZero = document.getElementById("enforceNonZero").checked;
  const debugMode = document.getElementById("debugMode").checked;
  
  if (isNaN(baseTime) || baseTime <= 0) {
    alert("Please enter a valid time value greater than 0.");
    return;
  }
  
  if (isNaN(maxChunks) || maxChunks <= 0 || maxChunks > 1000) {
    alert("Please enter a valid chunk count between 1 and 1000.");
    return;
  }
  
  if (isNaN(initialMaxWaitTime) || initialMaxWaitTime < 0) {
    alert("Please enter a valid maximum wait time (>= 0).");
    return;
  }
  
  // Call our search function with increasing wait times if needed
  tryWithWaitTime(initialMaxWaitTime);
  
  function tryWithWaitTime(maxWaitTime) {
    let speeds = [];
    let machineNames = [];
    let debugInfo = "Debug Information:\n\n";
    
    for (let i = 0; i < machineCount; i++) {
      const val = parseFloat(document.getElementById(`machine${i}`).value);
      if (isNaN(val)) continue; // machine excluded
      if (val <= -100) {
        alert(`Machine ${i+1} cannot be more than 100% slower (value <= -100%)`);
        return;
      }
      
      const relativeSpeed = 1 + (val / 100);
      speeds.push(relativeSpeed);
      machineNames.push(`Machine ${i + 1}`);
    }
    
    if (speeds.length < 2) {
      alert("Please provide data for at least two machines.");
      return;
    }
    
    const baseSpeed = speeds[0];
    const normalizedSpeeds = speeds.map(s => s / baseSpeed);
    
    debugInfo += `Machine count: ${speeds.length}\n`;
    debugInfo += `Relative speeds: ${speeds.join(", ")}\n`;
    debugInfo += `Normalized speeds: ${normalizedSpeeds.join(", ")}\n`;
    debugInfo += `Base time: ${baseTime} minutes\n`;
    debugInfo += `Max chunks: ${maxChunks}\n`;
    debugInfo += `Max wait time: ${maxWaitTime} minutes\n`;
    debugInfo += `Enforce non-zero: ${enforceNonZero}\n\n`;
    
    let best = null;
    const resultBox = document.getElementById("result");
    resultBox.value = "Calculating...";
    
    // Function to generate all possible distributions
    function generateDistributions(totalChunks, machines, callback) {
      // Prepare an array to track the best distribution found
      let bestDistribution = null;
      let bestWaitTime = Infinity;
      
      function helper(current, remaining, index) {
        // If we've already found a solution better than maxWaitTime, we can return
        if (bestWaitTime <= maxWaitTime && totalChunks > machines * 2) {
          return true;
        }
        
        // If we're at the last machine, assign all remaining chunks to it
        if (index === machines - 1) {
          current.push(remaining);
          
          // Skip if enforceNonZero is true and any machine has 0 chunks
          if (enforceNonZero && current.includes(0)) {
            current.pop();
            return false;
          }
          
          // FIX: Skip if all chunks are assigned to the last machine only
          // But only if we're enforcing non-zero or if it's not mathematically optimal
          if (!enforceNonZero && remaining === totalChunks && machines > 1) {
            // In this case, check if this is actually optimal by comparing speeds
            let lastMachineSpeed = normalizedSpeeds[machines - 1];
            let isFastest = true;
            
            for (let i = 0; i < machines - 1; i++) {
              if (normalizedSpeeds[i] >= lastMachineSpeed) {
                isFastest = false;
                break;
              }
            }
            
            // Only skip if the last machine isn't the fastest
            if (!isFastest) {
              current.pop();
              return false;
            }
          }
          
          // Calculate times for this distribution
          const times = current.map((chunks, i) => {
            return chunks * (baseTime / totalChunks) / normalizedSpeeds[i];
          });
          
          // Calculate wait time (difference between max and min non-zero time)
          const nonZeroTimes = times.filter((t, i) => current[i] > 0);
          const maxTime = Math.max(...nonZeroTimes);
          const minTime = Math.min(...nonZeroTimes);
          const waitTime = maxTime - minTime;
          
          // Update best if this is better
          if (waitTime < bestWaitTime) {
            bestWaitTime = waitTime;
            bestDistribution = [...current];
            
            // Call the callback with this distribution
            callback(bestDistribution, times, waitTime, totalChunks);
          }
          
          current.pop();
          return bestWaitTime <= maxWaitTime;
        }
        
        // Try different chunk counts for the current machine
        const minChunks = enforceNonZero ? 1 : 0;
        const maxChunksForThisMachine = remaining - (enforceNonZero ? (machines - index - 1) : 0);
        
        // FIX: Make sure we try realistic distributions when not enforcing non-zero
        // Especially important to try giving this machine some chunks, not just 0
        if (!enforceNonZero) {
          // Calculate a reasonable amount based on speed ratios if we're not enforcing non-zero
          const totalSpeedRatio = normalizedSpeeds.reduce((a, b) => a + b, 0);
          const thisRatio = normalizedSpeeds[index] / totalSpeedRatio;
          const idealChunks = Math.round(thisRatio * totalChunks);
          
          // Try the ideal chunk count first
          const boundedIdeal = Math.min(Math.max(idealChunks, 0), maxChunksForThisMachine);
          
          // Try the ideal first, then try other values
          if (boundedIdeal <= maxChunksForThisMachine) {
            current.push(boundedIdeal);
            const shouldBreak = helper(current, remaining - boundedIdeal, index + 1);
            current.pop();
            
            if (shouldBreak) return true;
          }
        }
        
        // Now try the rest systematically (either around the ideal point or from start)
        for (let i = minChunks; i <= maxChunksForThisMachine; i++) {
          current.push(i);
          const shouldBreak = helper(current, remaining - i, index + 1);
          current.pop();
          
          if (shouldBreak) return true;
        }
        
        return false;
      }
      
      // Start the recursive helper with an empty distribution
      return helper([], totalChunks, 0);
    }
    
    // Start searching from a reasonable starting point
    setTimeout(() => {
      // Calculate a good starting point for chunks based on machine speeds
      let minChunksToConsider = speeds.length;
      
      // For the example case (0, 0, 50) we want at least enough chunks to proportionally distribute
      // Let's calculate a minimum number of chunks based on speed ratios
      const speedSum = normalizedSpeeds.reduce((sum, speed) => sum + speed, 0);
      const lcmValue = calculateLeastCommonMultiple(normalizedSpeeds.map(speed => Math.round(speed * 100)));
      minChunksToConsider = Math.max(minChunksToConsider, Math.ceil(lcmValue / 100));
      
      if (enforceNonZero) {
        minChunksToConsider = Math.max(minChunksToConsider, speeds.length);
      }
      
      debugInfo += `Starting search from ${minChunksToConsider} chunks\n\n`;
      
      let foundExactSolution = false;
      for (let totalChunks = minChunksToConsider; totalChunks <= maxChunks; totalChunks++) {
        debugInfo += `Trying ${totalChunks} chunks...\n`;
        
        const foundSolution = generateDistributions(totalChunks, speeds.length, (distribution, times, waitTime, chunks) => {
          // Double check this isn't just assigning all chunks to the last machine
          if (!enforceNonZero) {
            let allToLast = true;
            for (let i = 0; i < distribution.length - 1; i++) {
              if (distribution[i] > 0) {
                allToLast = false;
                break;
              }
            }
            
            // If all chunks are going to the last machine and it's not the fastest, skip
            if (allToLast && distribution.length > 1) {
              let lastIdx = distribution.length - 1;
              let lastSpeed = normalizedSpeeds[lastIdx];
              let shouldSkip = false;
              
              for (let i = 0; i < lastIdx; i++) {
                if (normalizedSpeeds[i] > lastSpeed) {
                  shouldSkip = true;
                  break;
                }
              }
              
              if (shouldSkip) {
                debugInfo += `  Skipping invalid distribution (all to last): ${distribution.join("-")}\n`;
                return;
              }
            }
          }
          
          // Update our best solution
          if (!best || waitTime < best.waitTime) {
            best = {
              totalChunks: chunks,
              distribution,
              times,
              waitTime,
              percentages: distribution.map(c => (c / chunks * 100).toFixed(1) + "%")
            };
            
            debugInfo += `  New best: Wait time = ${waitTime.toFixed(4)}, Distribution = ${distribution.join("-")}\n`;
          }
        });
        
        // If we found a good enough solution, break out
        if (foundSolution || (best && best.waitTime <= maxWaitTime && totalChunks >= speeds.length * 2)) {
          foundExactSolution = true;
          debugInfo += `Found solution within wait time threshold (${maxWaitTime} minutes)\n`;
          break;
        }
      }
      
      if (!foundExactSolution && best) {
        debugInfo += `Couldn't find solution within threshold. Best wait time: ${best.waitTime.toFixed(4)} minutes\n`;
      }
      
      // Display the debug info
      document.getElementById("debugInfo").textContent = debugInfo;
      
      // Handle the no solution found case - AUTO-ADJUST THE WAIT TIME
      if (!best) {
        // If we've tried with a very high wait time already, then give up
        if (maxWaitTime > baseTime * 0.5) {
          resultBox.value = `No optimal solution found within ${maxChunks} chunks.\nTry increasing the maximum chunks.`;
          document.getElementById("visualization").innerHTML = "";
          return;
        }
        
        // Otherwise, try with a higher wait time
        const newWaitTime = maxWaitTime * 2;
        resultBox.value = `No solution found with wait time ${maxWaitTime} minutes.\nTrying with wait time ${newWaitTime} minutes...`;
        
        // Try again with increased wait time
        setTimeout(() => {
          tryWithWaitTime(newWaitTime);
        }, 100);
        return;
      }
      
      // Format the output
      let output = `OPTIMAL WORK DISTRIBUTION\n`;
      output += `=========================\n\n`;
      output += `Total chunks: ${best.totalChunks}\n`;
      output += `Maximum completion time: ${Math.max(...best.times.filter((t, i) => best.distribution[i] > 0)).toFixed(2)} minutes\n`;
      output += `Wait time (difference between fastest and slowest): ${best.waitTime.toFixed(2)} minutes\n`;
      
      // Add a note if we had to increase the wait time
      if (maxWaitTime > initialMaxWaitTime) {
        output += `\nNote: The maximum acceptable wait time was automatically increased from ${initialMaxWaitTime} to ${maxWaitTime} minutes to find a solution.\n`;
      }
      
      output += `\nDISTRIBUTION SUMMARY\n`;
      output += `===================\n`;
      best.distribution.forEach((chunks, i) => {
        const percentage = (chunks / best.totalChunks * 100).toFixed(1);
        output += `${machineNames[i]}: ${chunks} chunks (${percentage}% of total work)\n`;
      });
      
      output += `\nDETAILED RESULTS\n`;
      output += `===============\n`;
      best.distribution.forEach((chunks, i) => {
        output += `${machineNames[i]}:\n`;
        output += `  Speed: ${normalizedSpeeds[i].toFixed(2)}x base machine\n`;
        output += `  Chunks assigned: ${chunks} (${best.percentages[i]} of total work)\n`;
        
        if (chunks > 0) {
          output += `  Estimated completion time: ${best.times[i].toFixed(2)} minutes\n`;
          const speedup = baseTime / best.times[i];
          output += `  Speedup compared to base machine alone: ${speedup.toFixed(2)}x\n`;
        } else {
          output += `  No work assigned\n`;
        }
        output += `\n`;
      });
      
      // If there are machines with zero work, explain why
      const zeroWorkMachines = best.distribution.filter(chunks => chunks === 0).length;
      if (zeroWorkMachines > 0 && !enforceNonZero) {
        output += `NOTE: ${zeroWorkMachines} machine(s) were assigned no work. This is mathematically optimal but you can\nforce all machines to get work by enabling "Ensure all machines get work" in Advanced Settings.\n`;
      }
      
      resultBox.value = output;
      
      // Create visual representation
      createVisualization(best, machineNames, normalizedSpeeds);
    }, 10); // Small timeout to not block the UI
  }
}

// Helper functions remain the same...


	
function gcd(a, b) {
	  a = Math.abs(a);
	  b = Math.abs(b);
	  while (b) {
		let t = b;
		b = a % b;
		a = t;
	  }
	  return a;
	}

	// Helper function to calculate LCM
	function lcm(a, b) {
	  return Math.abs(a * b) / gcd(a, b);
	}

	// Helper function to calculate LCM of an array of numbers
	function calculateLeastCommonMultiple(numbers) {
	  return numbers.reduce((acc, num) => lcm(acc, num), 1);
	}

    function createVisualization(result, machineNames, normalizedSpeeds) {
      const visContainer = document.getElementById("visualization");
      visContainer.innerHTML = "<h3>Visual Comparison</h3>";
      
      // Filter out machines with zero work for visualization
      const nonZeroMachineIndices = result.distribution.map((chunks, i) => ({chunks, i}))
                                    .filter(item => item.chunks > 0)
                                    .map(item => item.i);
      
      const maxTime = Math.max(...result.times.filter((_, i) => nonZeroMachineIndices.includes(i)));
      
      nonZeroMachineIndices.forEach(i => {
        const machineBar = document.createElement("div");
        machineBar.className = "machine-bar";
        
        const machineProgress = document.createElement("div");
        machineProgress.className = "machine-progress";
        machineProgress.style.width = `${(result.times[i] / maxTime) * 100}%`;
        machineProgress.textContent = `${machineNames[i]}: ${result.times[i].toFixed(2)} min`;
        
        machineBar.appendChild(machineProgress);
        visContainer.appendChild(machineBar);
      });
      
      // Add a comparison to a naive equal distribution
      visContainer.innerHTML += "<h3>Comparison: Optimized vs. Equal Distribution</h3>";
      
      // Create equal distribution (only for non-zero machines)
      const activeIndices = result.distribution.map((chunks, i) => i).filter(i => result.distribution[i] > 0);
      const equalChunks = result.totalChunks / activeIndices.length;
      
      const equalTimes = activeIndices.map(i => {
        const partTime = document.getElementById("totalTime").value / normalizedSpeeds[i];
        return equalChunks * (1 / result.totalChunks) * partTime;
      });
      
      const maxEqualTime = Math.max(...equalTimes);
      
      visContainer.innerHTML += "<p><strong>Optimized Distribution</strong></p>";
      
      activeIndices.forEach((i, index) => {
        const machineBar = document.createElement("div");
        machineBar.className = "machine-bar";
        
        const machineProgress = document.createElement("div");
        machineProgress.className = "machine-progress";
        machineProgress.style.width = `${(result.times[i] / maxEqualTime) * 100}%`;
        

		// In the visualization function, continuing from the end:
		machineProgress.textContent = `${machineNames[i]}: ${result.times[i].toFixed(2)} min (${result.percentages[i]})`;

		machineBar.appendChild(machineProgress);
		visContainer.appendChild(machineBar);
		});

		visContainer.innerHTML += "<p><strong>Equal Distribution</strong></p>";

		activeIndices.forEach((i, index) => {
		  const machineBar = document.createElement("div");
		  machineBar.className = "machine-bar";

		  const machineProgress = document.createElement("div");
		  machineProgress.className = "machine-progress";
		  machineProgress.style.width = `${(equalTimes[index] / maxEqualTime) * 100}%`;
		  machineProgress.style.backgroundColor = "#ff9800";
		  machineProgress.textContent = `${machineNames[i]}: ${equalTimes[index].toFixed(2)} min (equal time-based estimate)`;

		  machineBar.appendChild(machineProgress);
		  visContainer.appendChild(machineBar);
		});

		// Add efficiency comparison
		const optimizedTotal = Math.max(...result.times.filter((_, i) => result.distribution[i] > 0));
		const equalTotal = Math.max(...equalTimes);
		const improvement = ((equalTotal - optimizedTotal) / equalTotal * 100).toFixed(2);

		const efficiencyInfo = document.createElement("div");
		efficiencyInfo.innerHTML = `
		  <p>
			<strong>Efficiency improvement: ${improvement}%</strong><br>
			Equal distribution completion time: ${equalTotal.toFixed(2)} minutes<br>
			Optimized distribution completion time: ${optimizedTotal.toFixed(2)} minutes<br>
			Time saved: ${(equalTotal - optimizedTotal).toFixed(2)} minutes
		  </p>
		`;
		visContainer.appendChild(efficiencyInfo);
		}
  </script>
</body>
</html>